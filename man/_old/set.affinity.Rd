% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rzmq.R
\name{set.affinity}
\alias{set.affinity}
\title{Polls a list of sockets.}
\usage{
set.affinity(socket, option.value)
}
\arguments{
\item{socket}{Socket.}

\item{option.value}{Affinity.}

\item{sockets}{List of sockets.}

\item{events}{A list of character vector corresponding to the events the
corresponding socket responds to. Valid events are {"read", "write", "error"}}

\item{timeout}{Time to wait for an event in seconds.
A timeout of -1L blocks until an event occurs.
A timeout of 0L is non-blocking.}
}
\value{
A list of pairlists corresponding to the polled sockets.
Each list has one of more tags from {"read", "write", "error"} with 
logical values indicating the results of the poll operation.

`TRUE` if the option was set successfully, `FALSE` otherwise.
}
\description{
Polls a list of sockets.
}
\examples{
# Create a set of REP-REQ sockets that
# have a Send, Receive, Send, Receive, ...
# pattern.
context = init.context()
in.socket = init.socket(context,"ZMQ_REP")
bind.socket(in.socket,"tcp://*:5557")
out.socket = init.socket(context,"ZMQ_REQ")
connect.socket(out.socket,"tcp://*:5557")
# Poll the REP and REQ sockets for all events.
events <- poll.socket(list(in.socket, out.socket),
                      list(c("read", "write", "error"),
                           c("read", "write", "error")),
                      timeout=0L)
# The REQ socket is writable without blocking.
paste("Is upstream REP socket readable without blocking?", events[[1]]$read)
paste("Is upstream REP socket writable without blocking?", events[[1]]$write)
paste("Is downstream REQ socket readable without blocking?", events[[2]]$read)
paste("Is downstream REQ socket writable without blocking?", events[[2]]$write)
# Send a message to the REP socket from the REQ socket. The
# REQ socket must respond before the REP socket can send
# another message.
send.socket(out.socket, "Hello World")
events <- poll.socket(list(in.socket, out.socket),
                      list(c("read", "write", "error"),
                           c("read", "write", "error")),
                      timeout=0L)
# The incoming message is readable on the REP socket.
paste("Is upstream REP socket readable without blocking?", events[[1]]$read)
paste("Is upstream REP socket writable without blocking?", events[[1]]$write)
paste("Is downstream REQ socket readable without blocking?", events[[2]]$read)
paste("Is downstream REQ socket writable without blocking?", events[[2]]$write)
receive.socket(in.socket)
poll.socket <- function(sockets, events, timeout=0L) {
    if (timeout != -1L) timeout <- as.integer(timeout * 1e3)
    .Call("pollSocket", sockets, events, timeout)
}
events <- poll.socket(list(in.socket, out.socket),
                      list(c("read", "write", "error"),
                           c("read", "write", "error")),
                      timeout=0L)
# The REQ socket is waiting for a response from the REP socket.
paste("Is upstream REP socket readable without blocking?", events[[1]]$read)
paste("Is upstream REP socket writable without blocking?", events[[1]]$write)
paste("Is downstream REQ socket readable without blocking?", events[[2]]$read)
paste("Is downstream REQ socket writable without blocking?", events[[2]]$write)
send.socket(in.socket, "Greetings")
events <- poll.socket(list(in.socket, out.socket),
                      list(c("read", "write", "error"),
                           c("read", "write", "error")),
                      timeout=0L)
# The REP response is waiting to be read on the REQ socket.
paste("Is upstream REP socket readable without blocking?", events[[1]]$read)
paste("Is upstream REP socket writable without blocking?", events[[1]]$write)
paste("Is downstream REQ socket readable without blocking?", events[[2]]$read)
paste("Is downstream REQ socket writable without blocking?", events[[2]]$write)
# Complete the REP-REQ transaction cycle by reading
# the REP response.
receive.socket(out.socket)
Set the I/O thread affinity for newly created connections of the socket.
See ZMQ socket option `ZMQ_AFFINITY`.

context <- init.context()
socket <- init.socket(context, "ZMQ_REP")
set.affinity(socket, 1L)
}
